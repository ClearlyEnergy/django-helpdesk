import os
import logging
from smtplib import SMTPException

from django.utils.safestring import mark_safe
from seed.lib.superperms.orgs.models import Organization
from seed.utils.email import send_beam_mail, add_custom_header
from post_office.models import Email
from django.template import Template, Context
from bs4 import BeautifulSoup
from markdown import markdown
from html import unescape


DEBUGGING = False


def _process_text(text, org):
    from helpdesk.models import get_markdown
    if text is None:
        return None, None
    text = ''.join(BeautifulSoup(text, features="html.parser").find_all(text=True))  # first, begone html! not allowed!

    html_text = get_markdown(text, org=org)  # next, convert what remains, from markdown -> html

    # For the plaintext, remove the html content generated by markdown text
    soup = BeautifulSoup(html_text, features="html.parser")
    for tag in soup.find_all('a'):
        tag.replace_with(f"{tag.string} ({tag['href']})")  # preserve links
    plain_text = ''.join(soup.find_all(text=True))

    html_text = html_text.replace('\r\n', '<br>')

    """
    plain_trunc = plain_text
    if len(plain_trunc) > 2000:
        plain_trunc = plain_trunc[:2001] + '...'
    if len(plain_trunc.splitlines(True)) > 10:
        plain_trunc = ''.join(plain_trunc.splitlines(True)[:11])
        plain_trunc += '...'

    html_trunc = html_text
    if len(html_trunc) > 3000:
        html_trunc = html_trunc[:3001] + '...'
        html_trunc = BeautifulSoup(html_trunc).prettify()
    if len(html_trunc.splitlines(True)) > 15:
        html_trunc = ''.join(html_trunc.splitlines(True)[:16] + ["..."])
    """

    plain_text = mark_safe(plain_text)  # prevents characters from being converted to html entities
    html_text = mark_safe(html_text)

    return plain_text, html_text


def send_templated_mail(template_name,
                        context,
                        recipients,
                        sender=None,
                        bcc=None,
                        fail_silently=False,
                        files=None,
                        organization=None,
                        ticket_id=None,
                        extra_headers=None,
                        email_logger=None,
                        source='',
                        user=None):
    """
    send_templated_mail() is a wrapper around Django's e-mail routines that
    allows us to easily send multipart (text/plain & text/html) e-mails using
    templates that are stored in the database. This lets the admin provide
    both a text and a HTML template for each message.

    template_name is the slug of the template to use for this message (see
        models.EmailTemplate)

    context is a dictionary to be used when rendering the template

    recipients can be either a string, eg 'a@b.com', or a list of strings.

    sender should contain a string, eg 'My Site <me@z.com>'. If you leave it
        blank, it'll use settings.DEFAULT_FROM_EMAIL as a fallback.

    bcc is an optional list of addresses that will receive this message as a
        blind carbon copy.

    fail_silently is passed to Django's mail routine. Set to 'True' to ignore
        any errors at send time.

    files can be a list of tuples. Each tuple should be a filename to attach,
        along with the File objects to be read. files can be blank.

    extra_headers is a dictionary of extra email headers, needed to process
        email replies and keep proper threading.

    """
    from django.core.mail import BadHeaderError
    from django.template import engines
    from_string = engines['django'].from_string

    from helpdesk.models import EmailTemplate
    from helpdesk.settings import HELPDESK_EMAIL_SUBJECT_TEMPLATE, \
        HELPDESK_EMAIL_FALLBACK_LOCALE

    if email_logger:
        logger = email_logger
    else:
        logger = logging.getLogger(__name__)

    headers = extra_headers or {}
    for key, value in headers.items():
        headers[key] = value.strip()

    locale = context['queue'].get('locale') or HELPDESK_EMAIL_FALLBACK_LOCALE

    org_id = context['queue'].get('organization_id', None)
    org = Organization.objects.get(id=org_id)

    try:
        t = EmailTemplate.objects.get(template_name__iexact=template_name, locale=locale, organization=organization)
    except EmailTemplate.DoesNotExist:
        try:
            t = EmailTemplate.objects.get(template_name__iexact=template_name, locale__isnull=True, organization=organization)
        except EmailTemplate.DoesNotExist:
            logger.warning('template "%s" does not exist, no mail sent', template_name)
            return  # just ignore if template doesn't exist

    subject_part = from_string(
        HELPDESK_EMAIL_SUBJECT_TEMPLATE % {
            "subject": t.subject
        }).render(context).replace('\n', '').replace('\r', '')

    footer_file = os.path.join('helpdesk', locale, 'email_text_footer.txt')

    # Marking urls and email addresses safe, so that their & and <> symbols aren't escaped
    if 'ticket_url' in context['ticket']:
        context['ticket']['ticket_url'] = mark_safe(context['ticket']['ticket_url'])
    if 'staff_url' in context['ticket']:
        context['ticket']['staff_url'] = mark_safe(context['ticket']['staff_url'])
    if 'email_address' in context['queue']:
        context['queue']['email_address'] = mark_safe(context['queue']['email_address'])

    # Turn Markdown formatting into html
    if 'comment' in context:
        context['comment'], html_comment = _process_text(context['comment'], org)
    if 'description' in context['ticket']:
        context['ticket']['description'], html_description = _process_text(context['ticket']['description'], org)
    # for some reason the resolution can be in either...
    if 'resolution' in context:
        context['resolution'], html_resolution = _process_text(context['resolution'], org)
    if 'resolution' in context['ticket']:
        context['ticket']['resolution'], html_resolution = _process_text(context['ticket']['resolution'], org)

    # Create plain text from context
    text_part = from_string(
        "%s\n\n{%% include '%s' %%}" % (t.plain_text, footer_file)
    ).render(context)

    # file found in helpdesk/templates/helpdesk/[locale]/
    email_html_base_file = os.path.join('helpdesk', locale, 'email_html_base.html')

    if 'comment' in context:
        context['comment'] = html_comment
    if 'description' in context['ticket']:
        context['ticket']['description'] = html_description
    if 'resolution' in context:
        context['resolution'] = html_resolution
    if 'resolution' in context['ticket']:
        context['ticket']['resolution'] = html_resolution

    html_part = from_string(
        "{%% extends '%s' %%}"
        "{%% block title %%}%s{%% endblock %%}"
        "{%% block content %%}%s{%% endblock %%}" %
        (email_html_base_file, t.heading, t.html)
    ).render(context)

    recipients, headers['X-BEAMHelpdesk-Delivered'] = add_custom_header(recipients)

    try:
        # Create and send email out.
        success = send_beam_mail(
            organization=org,  # todo this should use the sender given to it
            recipient_emails=recipients,
            bcc=bcc,
            subject=subject_part,
            msg_plain=text_part,
            msg_html=html_part,
            files=files,
            headers=headers,
            source_page=Email.HELPDESK,
            source_action=source,
            user=user,
            ticket_id=ticket_id,
        )
    except SMTPException as e:
        logger.exception('SMTPException raised while sending email from {} to {}'.format(sender, recipients))
        if not fail_silently:
            raise e
        return 0
    except BadHeaderError as e1:
        logger.exception('BadHeaderError raised while sending email from {} to {}.'.format(sender, recipients))
        if not fail_silently:
            raise e1
        return 0
    except Exception as e2:
        logger.exception('Raised failure while sending email from {} to {}'.format(sender, recipients))
        if not fail_silently:
            raise e2
        return 0
